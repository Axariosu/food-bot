    

import util.alphafuseutil as alphafuseutil
import util.uddercodeutil as uddercodeutil
import util.util as util
import uuid
import discord
import asyncio
import random
import time
import queue
from discord.ext import tasks
from discord.ext import commands


class GamesUtil(commands.Cog):
    @commands.command(aliases=['a25'], hidden=True)
    @commands.guild_only()
    async def alpha_25(self, ctx, arg1, brief="Usage: !alpha_25 <string>", description="Usage: !alpha_25 <string>, returns a list of at most 25 possible combinations for the given character combination."):
        """
        Returns a list of up to 25 valid words that satisfy the given letter combination. 
        """
        res = discord.Embed(title=discord.Embed.Empty, description=", ".join(alphafuseutil.get_many_possibilities(arg1)), color=util.generate_random_color())
        await ctx.send(embed=res)

    @commands.command(aliases=['o25'], hidden=True)
    @commands.guild_only()
    async def omega_25(self, ctx, arg1, brief="Usage: !omega_25 <string>", description="Usage: !omega_25 <string>, returns a list of at most 25 possible combinations for the given character combination."):
        """
        Returns a list of up to 25 valid words that satisfy the given letter combination. 
        """
        res = discord.Embed(title=discord.Embed.Empty, description=", ".join(alphafuseutil.get_random_possibility_inverted(arg1)), color=util.generate_random_color())
        await ctx.send(embed=res)

    @commands.command(aliases=['s25'], hidden=True)
    @commands.guild_only()
    async def sigma_25(self, ctx, arg1, brief="Usage: !sigma_25 <string>", description="Usage: !sigma_25 <string>, returns a list of at most 25 possible combinations for the given character combination."):
        """
        Returns a list of up to 25 valid words that satisfy the given letter combination. 
        """
        res = discord.Embed(title=discord.Embed.Empty, description=", ".join(alphafuseutil.get_many_possibilities_in_order(arg1)), color=util.generate_random_color())
        await ctx.send(embed=res)

    @commands.command(aliases=['sub25'], hidden=True)
    @commands.guild_only()
    async def substring_25(self, ctx, arg1, brief="Usage: !substring_25 <string>", description="Usage: !substring_25 <string>, returns a list of at most 25 possible combinations for the given character combination."):
        """
        Returns a list of up to 25 valid words that satisfy the given letter combination. 
        """
        res = discord.Embed(title=discord.Embed.Empty, description=", ".join(alphafuseutil.get_many_possibilities_substring(arg1)), color=util.generate_random_color())
        await ctx.send(embed=res)

    @commands.command(aliases=['fs'])
    async def findsolution(self, ctx, arg1, arg2, brief="Usage: !findsolution <code1> <code2>, alias='fs'", description="Usage: !findsolution <code1> <code2>, alias='fs'. Returns a solution path between code1 and code2. If <code2> == 'r', it will be autogenerated based on <code1>'s length."):
        """
        Returns a solution path between code1 and code2. 
        """
        # takes a long time to search through a list of 10^7+ or more entries
        if arg2 == "r":
            arg2 = uddercodeutil.generateRandomCode(len(arg1))
        if len(arg1) == len(arg2) <= 6:
            stack = queue.deque()
            solutionList = [str(x).zfill(len(arg1)) for x in range(len(uddercodeutil.numeric)**len(arg1))]
            start = time.time()
            uddercodeutil.TPOA(10, 2, 1, uddercodeutil.TPOANode(arg1), arg2, solutionList, stack)
            stop = time.time()
            uddercodeutil.reverseStack(stack)
            res = discord.Embed(title="UdderCode found!", color=util.generate_random_color())
            stringBuild, guess = "", 0
            while stack:
                a = stack.pop()
                guess += 1
                stringBuild += "Guess " + str(guess) + ": **"+ str(a[0].code) + "**, " + str(a[1]) + (" Bull, " if a[1] == 1 else " Bulls, ") + str(a[2]) + (" Cow\n" if a[2] == 1 else " Cows\n")
                
            res.add_field(name="Solution found at depth " + str(guess), inline=False, value=stringBuild)
            res.add_field(name="Time elapsed", inline=False, value=str(stop-start))
            await ctx.send(embed=res)

    @commands.command(hidden=True)
    @commands.guild_only()
    async def check(self, ctx, arg1):
        """
        Returns "valid" or "invalid" based on the submission. 
        """
        c = "Valid" if alphafuseutil.in_wordlist(arg1) else "Invalid"
        res = discord.Embed(title=c, color=util.generate_random_color())
        await ctx.send(embed=res)
    
    @commands.command(hidden=True)
    @commands.guild_only()
    async def ping(self, ctx):
        """
        `!ping`
        Displays ping to the server.
        """
        await ctx.send(str(round(ctx.bot.latency * 1000)) + "ms")

def setup(bot): 
    bot.add_cog(GamesUtil(bot))